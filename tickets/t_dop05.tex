\textbf{\LARGE dop 5. Сортировка.  Простейшие  алгоритмы --- сортировка  выбором,  вставками,  обменом.  Оценка  сложности алгоритмов сортировки. Быстрая сортировка и ее сложность в среднем и в наихудшем случаях.}

\textbf{Задача}

\faEye \ массив $x_1, \dots, x_n$.
Задача: переставить элементы массива так, чтобы элементы оказались упорядоченными: $x_1 \leqslant x_2 \leqslant \dots \leqslant x_n$.

\textbf{Сортировка выбором}

Проходим по массиву в поисках наименьшего элемента. Найденный минимум меняем местами с последним элементом. Неотсортированная часть массива уменьшилась на один элемент (не включает первый элемент, куда мы переставили найденный минимум). К этой неотсортированной части применяем те же действия — находим минимум и ставим его на первое место в неотсортированной части массива. И так продолжаем до тех пор, пока неотсортированная часть массива не уменьшится до одного элемента.

\begin{verbatim}
template<class T> 
void selectSort(T a[], int size) {
  for (int i = 0; i < size; i++) {
    int k = i;
    // Find minimum element
    for (int j = i + 1; j < size; j++)
      if (a[j] < a[k])
        k = j; // - current minimum index
    swap(a[k], a[i]);  // Swap current and minimum elements
  }
}
\end{verbatim}

\textbf{Сортировка вставками}

На каждом шаге алгоритма мы берем один из элементов массива, находим позицию для вставки в уже отсортированной части и вставляем. Стоит отметить что массив из 1-го элемента считается отсортированным.
Нумерация элементов массива начинается с 0 и заканчивается n-1.
Основной цикл алгоритма начинается не с 0-го элемента а с 1-го, потому что элемент до 1-го элемента будет нашей отсортированной последовательностью (помним что массив состоящий из одного элемента является отсортированным) и уже относительно этого элемента с номером 0 мы будем вставлять все остальные. Собственно код:

\begin{verbatim}
for(int i = 1;i < n; i++)         
    for(int j = i; j > 0 && x[j - 1] > x[j]; j--) 
	    swap(x[j - 1], x[j]);
\end{verbatim}

Функция swap меняет местами элементы x[j-1] и x[j]. Вложенный цикл ищет место для вставки.

\textbf{Сортировка обменами (пузырьком)}

Обходим массив от начала до конца, попутно меняя местами неотсортированные соседние элементы. В результате первого прохода на последнее место «всплывёт» максимальный элемент. Теперь снова обходим неотсортированную часть массива (от первого элемента до предпоследнего) и меняем по пути неотсортированных соседей. Второй по величине элемент окажется на предпоследнем месте. Продолжая в том же духе, будем обходить всё уменьшающуюся неотсортированную часть массива, запихивая найденные максимумы в конец.
\begin{verbatim}
for (int i = 0; i < N; i++)
    for (int j = 0; j < N - i; j++)
        if (x[j] > x[j + 1])
            swap(x[j], x[j + 1])
\end{verbatim}
\textbf{Быстрая сортировка}
\textit{Алгоритм:}
\begin{enumerate}
    \item Выбираем опорный элемент
    \item Разбиваем массив на 3 части
    \begin{itemize}
        \item Создаём переменные l и r — индексы соответственно начала и конца рассматриваемого подмассива
        \item Увеличиваем l, пока l-й элемент меньше опорного
        \item Уменьшаем r, пока r-й элемент больше опорного
        \item Если l всё ещё меньше r, то меняем l-й и r-й элементы местами, инкрементируем l и декрементируем r
        \item Если l вдруг становится больше r, то прерываем цикл
    \end{itemize}
    \item Повторяем рекурсивно, пока не дойдём до массива из 1 элемента
\end{enumerate}


\begin{verbatim}
void quick_sort(int *x, int size) {
    int i = 0, j = size - 1;
    int mid = x[size / 2];
    do {
        while(x[i] < mid) i++;
        while(x[j] > mid) j--;
        if (i <= j) {
            swap(x[i], x[j]);
            i++;
            j--;
        }
    } while (i <= j);
    
    if(j > 0)
        quick_sort(x, j + 1);
    if (i < size)
        quick_sort(&x[i], size - i);
}
\end{verbatim}
\textbf{Сложность}

\begin{tabular}{|c|c|c|c|c|}
    \hline
     Сортировка & Выбором & Вставками & Обменами & Быстрая \\
     \hline
     Худший случай & $\mathcal{O}(n^2)$ & $\mathcal{O}(n^2)$ & $\mathcal{O}(n^2)$ & $\mathcal{O}(n^2)$ \\
     \hline
     Лучший случай & $\mathcal{O}(n^2)$ & $\mathcal{O}(n)$ & $\mathcal{O}(n)$ & $\mathcal{O}(n \log n)$ \\
     \hline
     Средний случай & $\mathcal{O}(n^2)$ & $\mathcal{O}(n^2)$ & $\mathcal{O}(n^2)$ & $\mathcal{O}(n \log n)$ \\
     \hline
\end{tabular}


% -------- source --------
\bigbreak
[\cite{habr_sort}]