\textbf{\LARGE dop 22. Распределенные файловые системы. Доступ к директориям и файлам. Семантика одновременного доступа к одному файлу нескольких процессов. Кэширование и размножение файлов.}

\textbf{Файловый сервис} --- это то, что файловая система предоставляет своим клиентам, т.е. интерфейс с файловой системой.

\textbf{Файловый сервер} --- это процесс, который реализует файловый сервис.

\textbf{Интерфейс файлового сервера.}

В UNIX и MS-DOS файл --- не интерпретируемая последовательность байтов.
Большинство РС базируются на использовании среды UNIX и MS-DOS, они используют такие варианты понятия файла. 
Файл может иметь атрибуты (информация о файле, не являющаяся его частью).

Могут ли файлы модифицироваться после создания? Обычно да, но есть системы с неизменяемыми файлами --- нет проблем при кэшировании и размножении. 
Защита обеспечивается теми же механизмами, что и в однопроцессорных ЭВМ --- мандатами и списками прав доступа. 

\textbf{Мандат} --- своего рода билет, выданный пользователю для каждого файла с указанием прав доступа. 
Список прав доступа задает для каждого файла список пользователей с их правами. 
Простейшая --- UNIX схема, в которой различают три типа доступа (чтение, запись, выполнение), и три типа пользователей (владелец, члены его группы, и прочие).

Файловый сервис может базироваться на одной из двух моделей --- модели загрузки/разгрузки и модели удаленного доступа. 
В первом случае файл передается между клиентом (памятью или дисками) и сервером целиком, а во втором файл сервис обеспечивает множество операций (открытие, закрытие, чтение и запись части файла, сдвиг указателя, проверку и изменение атрибутов, и т.п.).

\textbf{Интерфейс сервера директорий.}

Обеспечивает операции создания и удаления директорий, именования и переименования файлов, перемещение файлов из одной директории в другую. 
Определяет алфавит и синтаксис имен. 
Все распределенные системы используют иерархическую ФС.

\textbf{Семантика разделения файлов.}

\textbf{UNIX-семантика.}

Если за операцией записи следует чтение, то результат определяется последней из предшествующих операций записи. 
В распределенной системе такой семантики достичь легко только в том случае, когда имеется один файл-сервер, а клиенты не имеют кэшей. 
При наличии кэшей семантика нарушается: надо либо сразу все изменения в кэшах отражать в файлах, либо менять семантику разделения файлов. 

Еще одна проблема --- трудно сохранить семантику общего указателя файла (в UNIX он общий для открывшего файл процесса и его дочерних процессов) --- для процессов на разных ЭВМ трудно иметь общий указатель.

\textbf{Неизменяемые файлы} --- очень радикальный подход к изменению семантики разделения файлов. 
Только две операции --- создать и читать. 
Можно заменить новым файлом старый, т.е. можно менять директории. 

Если один процесс читает файл, а другой его подменяет, то можно позволить первому процессу доработать со старым файлом в то время, как другие процессы могут уже работать с новым.

\textbf{Семантика сессий.}

Изменения открытого файла видны только тому процессу (или машине), который производит эти изменения, а лишь после закрытия файла становятся видны другим процессам (или машинам). 

Что происходит, если два процесса одновременно работали с одним файлом --- либо результат будет определяться процессом, последним закрывшим файл, либо можно только утверждать, что один из двух вариантов файла станет текущим.

\textbf{Транзакции.}
Процесс выдает операцию <НАЧАЛО ТРАНЗАКЦИИ>, сообщая тем самым, что последующие операции должны выполняться без вмешательства других процессов.
Затем выдает последовательность чтений и записей, заканчивающуюся операцией <КОНЕЦ ТРАНЗАКЦИИ>. 

Если несколько транзакций стартуют в одно и то же время, то система гарантирует, что результат будет таким, каким бы он был в случае последовательного выполнения транзакций (в неопределенном порядке).

\textbf{Кэширование}. 

В системе клиент-сервер с памятью и дисками есть четыре потенциальных места для хранения файлов или их частей. 

Во-первых, хранение файлов на дисках сервера. 
Нет проблемы когерентности, так как одна копия файла существует. 
Главная проблема - эффективность, поскольку для обмена с файлом требуется передача информации в обе стороны и обмен с диском. 

Кэширование в памяти сервера. 
Две проблемы --- помещать в кэш файлы целиком или блоки диска, и как осуществлять выталкивание из кэша. 
Коммуникационные издержки остаются. 

Избавиться от коммуникаций позволяет кэширование в машине клиента. 
Кэширование на диске клиента может не дать преимуществ перед кэшированием в памяти сервера, а сложность повышается значительно. 
Поэтому рассмотрим подробнее организацию кэширования в памяти клиента. 
a) кэширование в каждом процессе. (Хорошо, если с файлом активно работает один процесс --- многократно открывает и закрывает файл, читает и пишет, например в случае процесса базы данных). 
b) кэширование в ядре. (Накладные расходы на обращение к ядру). 
c) кэш-менеджер в виде отдельного процесса. (Ядро освобождается от функций файловой системы, но на пользовательском уровне трудно эффективно использовать память, особенно в случае виртуальной памяти. Возможна фиксация страниц, чтобы избежать обменов с диском). 

Оценить выбор того или иного способа можно только при учете характера приложений и данных о быстродействии процессоров, памятей, дисков и сети.

\textbf{Когерентность кэшей.} 

\textbf{Алгоритм со сквозной записью.}

Необходимость проверки, не устарела ли информация в кэше. 
Запись вызывает коммуникационные расходы (MS-DOS).

\textbf{Алгоритм с отложенной записью.} 

Через регулярные промежутки времени все модифицированные блоки пишутся в файл.
Эффективность выше, но семантика непонятная пользователю (UNIX).

\textbf{Алгоритм записи в файл при закрытии файла.} 

Реализует семантику сессий. 
Не намного хуже случая, когда два процесса на одной ЭВМ открывают файл, читают
его, модифицируют в своей памяти и пишут назад в файл. 

\textbf{Алгоритм централизованного управления.}

Можно выдержать семантику UNIX, но не эффективно, ненадежно, и плохо масштабируется.

% -------- source --------
\bigbreak
[\cite{parallel_lec5}]