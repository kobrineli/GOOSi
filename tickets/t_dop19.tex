\textbf{\LARGE dop 18. Понятие  о  парадигме  программирования.  Основные  парадигмы  программирования.  Языки  и  парадигмы программирования.}

\textbf{Парадигма программирования} --- cовокупность идей и понятий, определяющих стиль программирования.

\textbf{Императивная парадигма (процедурная)} основана на фон-неймановской модели компьютера. 
Основные понятия императивных языков программирования представляют собой абстракции основных понятий фон-неймановской модели. 

Любой императивный язык программирования включает в себя:
\begin{itemize}
    \item Понятие переменной --- абстрагирует понятие ячейки памяти.
    \item Понятие операции --- обобщает арифметико-логические команды.
    \item Понятие оператора --- абстрагирует общее понятие команды.
\end{itemize}

Операторы: присваивания, управления (циклы, операторы выбора, перехода и т.д.).

Далее во всех парадигмах рассмотрена задача перевернуть последовательность символов.

\textit{C}
\begin{lstlisting}[basicstyle=\ttfamily\small, frame=single] 
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#define MAX_ELEMENTS 1024
char * pInput= NULL;
char Buffer[MAX_ELEMENTS];
int main() {
    int current, count = 0;
    pInput= (char*)calloc(1, sizeof(char));
    while (fgets(Buffer, sizeofBuffer, stdin)) {
        int oldCount= count;
        current = strlen(Buffer);
        count += current;
        pInput = (char*)realloc(pInput, count+1);
        if (!pInput) {
            fprintf(stderr, "No memory");
            return 1;
        }  else strcat(pInput+ oldCount, Buffer);
    }
    for (char * pBegin= pInput, * pEnd= pInput + count - 1; 
        pBegin< pEnd; ++pBegin, --pEnd) {
        char t = *pBegin;
        *pBegin= *pEnd; *pEnd= t;
    }
    puts(pInput); 
    free(pInput);
    return 0;
}
    \end{lstlisting}
    
\bigbreak
\textbf{Объектная парадигма} основана на понятии объекта. 
Объект обладает состоянием и поведением.

\textit{Поведение} --- взаимодействие с другими объектами посредством сообщений.
Для каждого вида сообщения существуют обработчики, которые могут модифицировать состояние и посылать сообщения. 
Объекты с одинаковым поведением и набором состояний объединяются в классы.
Объектная парадигма сочетается с императивной.

\textit{Состояние} описывается набором переменных, а обработчики сообщений представляют собой процедуры или функции, имеющие доступ к состоянию.
Посылка сообщения сводится к вызову соответствующего обработчика.

Объектная парадигма основана на императивной.

\textit{C++}
    
\begin{lstlisting}[basicstyle=\ttfamily\small, frame=single]
#include <iostream>
#include <string>
 
class Circle {
   double radius;
   std::string color;
public:
   Circle(double r = 1.0, std::string c = "red") :
        radius(r), color(c){ }
   double getRadius() { return radius; }
   std::string getColor() { return color; }
   double getArea() { return radius*radius*3.1416; }
};
 
int main() {
   Circle c1(1.2, "blue");
   std::cout << "Radius=" << c1.getRadius()
        << " Area=" << c1.getArea()
        << " Color=" << c1.getColor() << std::endl;
 
   Circle c2(3.4);
   std::cout << "Radius=" << c2.getRadius()
        << " Area=" << c2.getArea()
        << " Color=" << c2.getColor() << std::endl;
   return 0;
}
\end{lstlisting}
    
\bigbreak
\textbf{Функциональная парадигма} основана на понятиях функция и выражение.

Основная операция --- вызов функции.

\textit{Выражение} --- это комбинация вызовов функций. 

Функции -- объекты первого порядка, то есть могут быть значениями переменных, возвращаемыми и передаваемыми значениями, могут быть созданы динамически.

При вызове функции вначале вычисляются выражения --- фактические параметры --- затем их значения подставляются вместо аргументов в выражение-тело функции.
Наконец, вычисляется значение тела, которое и будет значением вызова.

\textit{Основные понятия:}
\begin{itemize}
    \item Лисп-выражение --- это атом, либо список.
    \item Атом --- это либо символ (идентификатор), либо число.
    \item Список --- это последовательность членов списка, разделенных пробелами, заключенная в круглые скобки.
    
    Член списка — это либо атом, либо список.
    \item Есть специальный атом --- \texttt{nil}, который представляет собой пустой список. 
    Это единственный атом, который одновременно является и списком.
\end{itemize}

\textit{Lisp}
    
\begin{lstlisting}[basicstyle=\ttfamily\small, frame=single] 
(defun shift (l r)
    ( if (null l)
        r
        (shift (cdrl) (cons (car l) r))
    )
)
(defun reverse1 (s) (shift s nil)) 
    \end{lstlisting}
    
\bigbreak
\textbf{Логическая парадигма}:  парадигма программирования, основанная на математической логике — программы в ней задаются в форме логических утверждений и правил вывода.

Идея -- описать семантику задачи в терминах формул исчисления предикатов. 

Программа на Прологе = описание предикатов.

Пример: \texttt{append(L1, L2, L3)} -- истина, если \texttt{L3} -- конкатенация списков \texttt{L1} и \texttt{L2}.

Предикаты описываются двояко: факты и правила. 

Факт: ИмяПредиката(список\_константных\_аргументов). 

Правило: \texttt{P(X1,X2,X3,...) :- P1(X1,...), P2(X1,...,Y,...), ...}

:- означает импликацию, запятая в правой части -- логическое "и".

Правила соединяются в единую формулу путем логической операции "или". Фактически получаем единую формулу -- дизъюнкцию импликаций (каждое правило -- хорновский дизъюнкт).

\textit{Prolog}
    
\begin{lstlisting}[basicstyle=\ttfamily\small, frame=single] 
reverse1([], []).
reverse1([X|Q], Z) :- reverse1(Q, Y), append(Y, [X], Z).
    \end{lstlisting}


% -------- source --------
\bigbreak
[\cite{golovin}]