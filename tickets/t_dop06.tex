\textbf{\LARGE dop 6. Язык  ассемблера  как  машиннозависимый  язык  низкого  уровня.  Организация  ассемблерной  программы, секции кода и данных (на примере ассемблера nasm или masm). Основные  этапы подготовки к счёту ассемблерной программы: трансляция, редактирование внешних связей (компоновка), загрузка.}

\textbf{Язык ассемблера}

Как правило, вычислительная система состоит из следующих основных компонентов: центральный процессор, оперативная память и внешние устройства. 

Программа, предназначенная к выполнению, записывается в оперативную память в виде последовательности машинных инструкций (команд), т.е. цифровых кодов, обозначающих те или иные операции.

\textbf{Ассемблер} --- это программа, принимающая на вход текст, содержащий условные обозначения машинных программ, удобные для человека, и переводящий эти обозначения в последовательность соответствующих машинных команд понятных процессору. 
Язык таких условных обозначений называется \textbf{языком ассемблера}.

Программирование на языке ассемблера отличается от программирования на языках высокого уровня. 
В последних мы задаем лишь указания, а компилятор (программа, принимающая на вход программу на языке высокого уровня и выдающая эквивалентный машинный код) волен сам определять, какими ресурсами (регистрами и ячейками памяти) воспользоваться для хранения промежуточных результатов, какой алгоритм применить для решения какой-нибудь нетривиальной ситуации и т.д. 
В отличие от этого на языке ассемблера мы однозначно и недвусмысленно указываем, из каких машинных команд будет состоять наша программа, в этом понимании ассемблер не имеет практически никакой свободы.

\textbf{Структура ассемблерной программы}

Операционная система может установить пользовательской программе разные возможности по доступу к различным областям памяти. Область памяти может быть доступна для чтения, записи и исполнения.

В связи с этим, в современных языках ассемблера существует разделение виртуального адресного пространства на различные области памяти, так называемые секции. 
Эти секции определяются программистом в ходе создания программы.
В результате перевода (трансляции) текста программы каждая секция будет превращена в последовательность байт. 

При запуске программы каждая такая последовательность байт будет загружена в оперативную память и размещена в выделенных для нее ячейках памяти. 
В простых программах набор секций, как правило, ограничен тремя (не считая служебных): 
 \begin{itemize}
     \item .text --- секция кода.
     \item .data --- секция статических инициализированных данных.
     \item .bss --- секция статических неинициализированных данных, значения которых обнуляются операционной системой перед запуском программы.
 \end{itemize}
 
\textbf{Основные этапы подготовки к счёту ассемблерной программы}

\begin{enumerate}
    \item \textit{Трансляция} --- это перевод программы на языке ассемблера (в мнемониках) в машинные коды. После трансляции получается объектный файл.
    \item \textit{Компоновка (связывание)}. На входе компоновщика один или несколько объектных файлов, на выходе - программа, готовая к исполнению (исполняемый файл). Компоновщик объединяет несколько файлов в один, пересчитывает адреса, связывает вызовы функций из разных файлов, для вызовов библиотечных функций (при статическом связывании) -- добавляет их код в исполняемый файл и также связывает вызовы.
    \item Во время \textit{загрузки} программы секции из исполняемого файла загружаются в память и управление передается в точку входа программы. Также при загрузке происходит связывание с динамическими библиотеками.
\end{enumerate}

\textbf{Пример ассемблерной программы (язык nasm)}

Программа, которая печатает 2 числа на экран:

\begin{lstlisting}[basicstyle=\ttfamily\small, frame=single] 
; Equivalent C code
; int main()
; {
;   int a=5;
;   printf("a=%d, eax=%d\n", a, a+2);
;   return 0;
; }

    extern printf	; the C function, to be called

    SECTION .data	; Data section, initialized variables
a:  dd 5		; int a=5;
fmt:db "a=%d, eax=%d", 10, 0 ; The printf format, "\n",'0'

    SECTION .text       ; Code section.
    global main         ; the standard gcc entry point
main:               ; the program label for the entry point
    push ebp            ; set up stack frame
    mov ebp,esp

    mov eax, [a]        ; put a from store into register
    add eax, 2          ; a+2
    push eax            ; value of a+2
    push dword [a]      ; value of variable a
    push dword fmt      ; address of ctrl string
    call printf         ; Call C function
    add esp, 12         ; pop stack 3 push times 4 bytes

    mov esp, ebp        ; takedown stack frame
    pop ebp             ; same as "leave" op

    mov	eax,0           ; normal, no error, return value
    ret	                ; return
\end{lstlisting}

% -------- source --------
\bigbreak
[\cite{padaryan}]